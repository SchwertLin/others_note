[TOC]



# 一、  简介

## 1.1 项目描述

某企业为了方便员工用餐，为餐厅开发了一个订餐外卖系统，员工作为顾客可通过企业内联网使用该系统。系统用户为顾客、餐厅员工、餐厅经理等。

- 顾客：可以查看菜单、订餐（如果未登录，需先登录）、支付、投诉等。
- 餐厅员工：可以进行接受订单、生成付费请求、备餐和请求送餐。
- 餐厅经理：餐厅管理层，可以管理菜单、查看每日销售情况及简单数据统计、投诉。

顾客订餐过程如下：

1. 顾客请求查看系统显示的菜单；

2. 顾客选菜；

3. 系统显示订单和价格及可送餐时间；

4. 顾客确认订单，指定送餐时间、地点并支付；

5. 系统确认接受订单，给顾客的界面可显示订单状态（确认中、备餐中、送餐中及预计到达时间），同时发送相关订餐信息通知给餐厅员工。

 

## 1.2 开发环境与工具

OS：Windows 11

后端：Java 1.8，apache-maven-3.8.4，mysql-connector-java-8.0.31

前端：H5、Vue.js、ElementUI



# 二、  需求分析

对于题目进行分析得，具体要求实现不同人员的功能。而最主要的人员是顾客以及餐厅管理员。在进行分析后，我们认为：由于该订餐外卖系统是用于企业内网以及员工餐厅的，其商家实际上只有承包公司一家，而且其窗口数量也是有限的。因此考虑对上述题目中的功能与人员进行简化：将其认为是一家商家，但是有很多的餐品种类。对于每一个窗口，应该都有餐厅员工，但是有些员工主要负责的是餐品的制作，而有些主要是管理订单。但是员工的权限显然不可能很高。因此对其进行简化：将顾客生成订单，并将该订单的请求传递给餐厅经理。(如果该餐厅的规格比较大，那将考虑将权利下放给餐厅员工)

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

​    由于不确定时间是否足够，因此我们确定下最主要的消费的员工以及管理员的数据库的构建以及功能的确定。对于数据库的表结构的创建，需要与实际相结合：

- 在实际的下单过程中，我们会选择自己心仪的商家与餐品，并对份数以及口味进行选择；
- 同时在下栏的购物车中，可以显示已选择的餐品的详细信息（指份数、口味之类）以及总计金额等。还能够进行加减先前勾选的餐品的功能以及一键清空购物车；
- 在点击下单后，将会跳转到相应的结算页面。将会对消费者显示详细的点餐信息。同时，消费者将选择送餐的地址；最终将提交订单。
- 当订单选择好之后将会将该信息发送到管理端：管理员会选择是否接受这份订单。接收后应将餐品信息发送到相应的窗口的员工那进行管理。

 

而对于管理员，其主要的功能是：

- 登入登出
- 对员工的信息进行管理(增删改查)
- 对餐品、套餐、口味、分类等进行管理
- 对订单进行管理

 

对于顾客的主要功能如下：

- 登入登出
- 点菜下单
- 地址管理
- 获知订单状态
- 历史订单显示

##  2.1 数据库的搭建

首先确定表结构，然后准备好相应的样例数据先输入。

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image062.jpg)

在此我们确定了一共11个表结构，分别是：

- `employee`：管理员与员工信息表。

- `user`：顾客信息表。
- `address_book`：地址簿，每位顾客可以设置多个地址。
- `dish`：餐品管理表。
- `dish_flavor`：餐品关口味关系表。
- `setmeal`：套餐表。
- `setmeal_dish`：套餐餐品关系表。
- `category`：餐品以及套餐分类表。
- `order`：订单表，存放订单的状态以及顾客的地址。
- `oeder_detail`：订单中餐品的详细信息表。
- `shopping_cart`：购物车表，显示选中的餐品以及详细信息。

其相应的E-R图如下：

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image064.gif)

 

# 三、  技术架构

## 3.1 项目环境搭建

后端：Java 1.8，apache-maven-3.8.4，mysql-connector-java-8.0.31

前端：H5、Vue.js、ElementUI

### 3.1.1 pom.xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.5</version>
        <relativePath/>
        <!--  lookup parent from repository  -->
    </parent>

    <groupId>org.tx</groupId>
    <artifactId>TakeawaySystem</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <java.version>1.8</java.version>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.2</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.20</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.76</version>
        </dependency>
        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.23</version>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.5</version>
            </plugin>
        </plugins>
    </build>

</project>
```



### 3.1.2 配置类

1. springboot中的目录结构中的static和templates：

**static**：默认存放静态资源文件，可以直接通过访问地址进行访问，或者通过控制器方法

**templates** :默认存放动态资源文件，需要引入thymeleaf引擎，通过控制器方法进行访问

静态页面的return默认是跳转到/static/目录下，当在pom.xml中引入了thymeleaf组件，动态跳转会覆盖默认的静态跳转，默认就会跳转到/templates/下，注意看两者return代码也有区别，动态没有html后缀。

2. 将backend(网页端)和front(移动端)以包的方式将页面放在resource下，然后通过配置信息类去进行资源绑定的映射。

```java
@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /*设置静态资源映射*/
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        log.info("start mapping static resources");
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");
        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");
    }
}
```

3. 配置R类（前后端交互协议的书写）

```java
//通用返回结果，服务器响应的数据最终都会封装成此对象
@Data
public class R<T> {

    private Integer code; //编码：1成功，0和其它数字为失败

    private String msg; //错误信息

    private T data; //数据

    private Map map = new HashMap(); //动态数据

    public static <T> R<T> success(T object) {
        R<T> r = new R<T>();
        r.data = object;
        r.code = 1;
        return r;
    }

    public static <T> R<T> error(String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }

    public R<T> add(String key, Object value) {
        this.map.put(key, value);
        return this;
    }
}
```



### 3.1.3 过滤器

主要作用：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。这里通过设置过滤器来进行登录的校验和页面数据的保护。

```java
//检查用户是否已经完成登录（过滤器）
@WebFilter(filterName = "LoginCheckFilter", urlPatterns = "/*")
@Slf4j
public class LoginCheckFilter implements Filter {
    //路径匹配器
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;        //HTTP请求
        HttpServletResponse response = (HttpServletResponse) servletResponse;    //HTTP响应

        //1.获取本次请求的URI
        String requestURI = request.getRequestURI();
        log.info("拦截到请求：{}", requestURI);
        //不需要处理的请求路径
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "/front/**",
                "/common/**"
        };

        //2.判断本次请求是否需要处理
        boolean check = check(urls, requestURI);

        //3.如果不需要处理，则直接放行
        if (check){
            log.info("本次请求不需要处理：{}", requestURI);
            filterChain.doFilter(request, response);
            return;
        }

        //4.判断登陆状态，如果已经登录，则直接放行
        if(request.getSession().getAttribute("employee") != null){
            log.info("用户已登录，用户ID为：{}", request.getSession().getAttribute("employee"));

            Long empId = (Long)request.getSession().getAttribute("employee");
            BaseContext.setCurrentId(empId);

            filterChain.doFilter(request, response);
            return;
        }

        if(request.getSession().getAttribute("user") != null){
            log.info("用户已登录，用户ID为：{}", request.getSession().getAttribute("user"));

            Long userId = (Long)request.getSession().getAttribute("user");
            BaseContext.setCurrentId(userId);

            filterChain.doFilter(request, response);
            return;
        }

        //5.如果未登录则返回为登陆结果,通过输出流方式向客户端页面响应数据
        log.info("用户未登录");
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
    }

    //路径匹配，检查本次请求是否需要放行
    public boolean check(String[] urls, String requestURI){
        for (String url : urls) {
            boolean match = PATH_MATCHER.match(url, requestURI);
            if(match){
                return true;
            }
        }
        return false;
    }
}
```

 

# 四、  实现设计

## 4.1 前端页面的搭建

前端页面可以根据用户类型分为管理端和客户端。

| ![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif) | ![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 管理端                                                       | 客户端                                                       |

### 4.1.1 管理端

#### 1) 登陆页面

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image014.gif" alt="descript" style="zoom: 40%;" /><img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image016.gif" alt="descript" style="zoom: 40%;" />

对登陆界面的密码输入框做了遮掩效果（type="password"），账号和密码输入框做了空缺提示，登陆的按钮实现了非加载和加载中两种状态，分别显示为“登陆”和“登陆中...”。

 

**右边输入框和登陆按钮具体代码如下：**

```javascript
<el-form-item prop="username">
    <el-input v-model="loginForm.username" type="text" auto-complete="off" placeholder="账号" maxlength="20" prefix-icon="iconfont icon-user" />
</el-form-item>
<el-form-item prop="password">
    <el-input v-model="loginForm.password" type="password" placeholder="密码" prefix-icon="iconfont icon-lock" maxlength="20" @keyup.enter.native="handleLogin" />
</el-form-item>
<el-form-item style="width:100%;">
    <el-button :loading="loading" class="login-btn" size="medium" type="primary" style="width:100%;" @click.native.prevent="handleLogin">
        <span v-if="!loading">登录</span>
        <span v-else>登录中...</span>
    </el-button>
</el-form-item>
```

 

#### 2) 目录页面

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image019.gif)

目录页面集成了“员工管理”、“分类管理”、“菜品管理”、“套餐管理”、“订单明细”这五大页面，对这五大页面进行了调用再增加了左侧的一个索引列表。

**左侧页面索引列表的实现代码如下：**

```javascript
<div v-for="item in menuList" :key="item.id">
  <el-submenu :index="item.id" v-if="item.children && item.children.length>0">
    <template slot="title">
      <i class="iconfont" :class="item.icon"></i>
      <span>{{item.name}}</span>
    </template>
    <el-menu-item
      v-for="sub in item.children"
      :index="sub.id"
      :key="sub.id"
      @click="menuHandle(sub,false)"
      >
      <i :class="iconfont" :class="sub.icon"></i>
      <span slot="title">{{sub.name}}</span>
    </el-menu-item>
  </el-submenu>
  <el-menu-item v-else :index="item.id" @click="menuHandle(item,false)">
      <i class="iconfont" :class="item.icon"></i>
      <span slot="title">{{item.name}}</span>
  </el-menu-item>
</div>
```

**menuList如下**

```javascript
menuList: [
    {
    id: '1',
    name: '员工管理',
    url: 'page/member/list.html',
    icon: 'icon-member'
    },
    {
    id: '2',
    name: '分类管理',
    url: 'page/category/list.html',
    icon: 'icon-category'
    },
    {
    id: '3',
    name: '菜品管理',
    url: 'page/food/list.html',
    icon: 'icon-food'
    },
    {
    id: '4',
    name: '套餐管理',
    url: 'page/combo/list.html',
    icon: 'icon-combo'
    },
    {
    id: '5',
    name: '订单明细',
    url: 'page/order/list.html',
    icon: 'icon-order'
    }
]
```

 

#### 3) 员工管理页面

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image022.gif)

页表有“员工姓名”、“账号”、“手机号”、“状态”、“操作”五个字段，能自动分隔，占满页面，不需要手动调整距离。左上还有查找功能，便于管理员快速找到对应的员工信息。右上角有“添加员工”按钮，便于管理员对员工进行增加操作。

**员工信息页表实现代码如下：**

```javascript
<el-table :data="tableData" stripe class="tableBox">
    <el-table-column prop="name" label="员工姓名"></el-table-column>
    <el-table-column prop="username" label="账号"></el-table-column>
    <el-table-column prop="phone" label="手机号"></el-table-column>
    <el-table-column label="账号状态">
      <template slot-scope="scope">
        {{ String(scope.row.status) === '0' ? '已禁用' : '正常' }}
      </template>
    </el-table-column>
<el-table-column label="操作" width="160" align="center">
```

**员工搜索框与添加按钮实现代码如下：**

```javascript
<div class="tableBar">
    <el-input v-model="input" placeholder="请输入员工姓名" style="width: 250px" clearable @keyup.enter.native="handleQuery">
        <i slot="prefix" class="el-input__icon el-icon-search" style="cursor: pointer" @click="handleQuery"></i>
    </el-input>
    <el-button type="primary" @click="addMemberHandle('add')">
        + 添加员工
    </el-button>
</div>
```

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image026.gif" alt="descript" style="zoom:50%;" />

点击右上的“添加员工”按钮能响应click事件，调用方法add，跳转到add.html页面，进行添加操作

**添加员工具体信息实现代码如下：**

```javascript
<el-form-item label="账号:" prop="username">
    <el-input v-model="ruleForm.username" placeholder="请输入账号" maxlength="20"/>
</el-form-item>
<el-form-item label="员工姓名:" prop="name">
    <el-input v-model="ruleForm.name" placeholder="请输入员工姓名" maxlength="20"/>
</el-form-item>
<el-form-item label="手机号:" prop="phone">
    <el-input v-model="ruleForm.phone" placeholder="请输入手机号" maxlength="20"/>
</el-form-item>
<el-form-item label="性别:" prop="sex">
    <el-radio-group v-model="ruleForm.sex">
        <el-radio label="男"></el-radio>
        <el-radio label="女"></el-radio>
    </el-radio-group>
</el-form-item>
<el-form-item label="身份证号:" prop="idNumber">
    <el-input v-model="ruleForm.idNumber" placeholder="请输入身份证号" maxlength="20"/>
</el-form-item>
```



#### 4) 分类管理页面

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image029.gif)

页表有“分类名单”、“分类类型”、“操作时间”、“排序”、“操作”五个字段，左上有“新增菜品分类”和“新增套餐分类”两个按钮可以对数据表进行扩充

**新增菜品分类和套餐分类实现代码如下：**

```javascript
<el-button type="primary" class="continue" @click="addClass('class')">
    + 新增菜品分类
</el-button>
<el-button type="primary" @click="addClass('meal')">
    + 新增套餐分类
</el-button>
```

```javascript
 // 弹窗添加
addClass(st) {
    if (st == 'class') {
        this.classData.title = '新增菜品分类'
        this.type = '1'
    } else {
        this.classData.title = '新增套餐分类'
        this.type = '2'
    }
    this.action = 'add'
    this.classData.name = ''
    this.classData.sort = ''
    this.classData.dialogVisible = true
    },
    editHandle(dat) {
    this.classData.title = '修改分类'
    this.action = 'edit'
    this.classData.name = dat.name
    this.classData.sort = dat.sort
    this.classData.id = dat.id
    this.classData.dialogVisible = true
    },
// 关闭弹窗
handleClose(st) {
    this.classData.dialogVisible = false
},
```



#### 5) 菜品/套餐管理页面

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image033.gif)

页表有“菜品名称”、“图片”、“菜品分类”、“售价”、“售卖状态”、“最后操作时间”、“操作”七个字段。左上有搜索框可以直接对菜品信息进行搜索，右上有“批量处理”和“新增菜品”四个按钮可以对菜品进行批量管理和增添，在有导入菜品数据之后还可以对菜品做删减处理

**菜品搜索框和批量处理、新增菜品按钮实现代码如下：**

```javascript
<template slot-scope="{ row }">
    <el-button type="text" @click="goDetail(row)" class="blueBug">
        查看
    </el-button>
    <el-divider v-if="row.status === 2" direction="vertical"></el-divider>
    <el-button v-if="row.status === 2" type="text" @click="cancelOrDeliveryOrComplete(3, row.id)" class="blueBug">
        派送
    </el-button>
    <el-divider v-if="row.status === 3" direction="vertical"></el-divider>
    <el-button v-if="row.status === 3" type="text" @click="cancelOrDeliveryOrComplete(4, row.id)" class="blueBug">
        完成
    </el-button>
</template>
```



#### 6) 订单明细页面

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)

对每个订单有五种状态“待付款”、“正在配送”、“已派送”、“已完成”、“已取消”。

**订单状态代码设计如下：**

```javascript
switch(row.status){
    case 1:
        str =  '待付款'
        break;
    case 2:
        str =  '正在派送'
        break;
    case 3:
        str =  '已派送'
        break;
    case 4:
        str =  '已完成'
        break;
    case 5:
        str =  '已取消'
        break;
    }
    return str
```

管理员可对每个订单进行“查看”、“派送”、“完成”三种操作。订单状态为“正在配送”时，管理员能对订单进行“配送”操作；同理，当订单状态为“已配送”时，管理员能对订单进行“完成”操作

**订操作代码实现如下：**

```javascript
<template slot-scope="{ row }">
    <el-button type="text" @click="goDetail(row)" class="blueBug">
        查看
    </el-button>
    <el-divider v-if="row.status === 2" direction="vertical"></el-divider>
    <el-button v-if="row.status === 2" type="text" @click="cancelOrDeliveryOrComplete(3, row.id)" class="blueBug">
        派送
    </el-button>
    <el-divider v-if="row.status === 3" direction="vertical"></el-divider>
    <el-button v-if="row.status === 3" type="text" @click="cancelOrDeliveryOrComplete(4, row.id)" class="blueBug">
        完成
    </el-button>
</template>
```



### 4.1.2客户端

#### 1) 登陆页面

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image040.gif" alt="descript" style="zoom:50%;" />

与管理端登陆页面类似，对密码做了遮掩处理，登陆的按钮实现了非加载和加载中两种状态，分别显示为“登陆”和“登陆中...”。

**登陆框设计代码如下：**

```javascript
<div class="divHead">登录</div>
<div class="divContainer">
    <el-input placeholder=" 请输入账号" v-model="form.username" maxlength='20'/></el-input>
    <el-input type="password" placeholder=" 请输入密码" v-model="form.password"  maxlength='20'/></el-input>
    <el-button :loading="loading" class="login-btn" size="medium" style="width:100%;" type="primary"  @click="btnLogin">
         <span v-if="!loading">登录</span>
         <span v-else>登录中...</span>
     </el-button>
</div>
```



#### 2) 功能主页面

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image043.jpg" alt="descript" style="zoom:50%;" />

页面顶部是店铺的简单介绍，包含“配送距离”、“配送费”、“配送时长”以及店铺的logo和口号标语。

**顶部店铺介绍设计代码如下**

```javascript
<div class="divTitle">
  <div class="divStatic">
    <img src="./images/logo2.png"  class="logo"/>
    <div class="divDesc">
      <div class="divName">外卖订餐</div>
      <div class="divSend">
          <span><img src="./images/time.png"/> 距离1.5km</span>
          <span><img src="./images/money.png"/> 配送费6元</span>
          <span><img src="./images/location.png"/> 预计时长12min</span>
      </div>
    </div>
  </div>
  <div class="divDesc">
    不闻人间烟火，但食人间美味！
  </div>
</div>
```

中间主体部分，左侧是“菜品分类”的滑动列表，右侧是“菜品细则”的滑动列表，皆能根据index自动索取相应数据。

**滑动列表设计代码如下：**

```javascript
<div class="divBody">
    //左侧分类列表
    <div class="divType">
        <ul>
        <li v-for="(item,index) in categoryList" :key="index" @click="categoryClick(index,item.id,item.type)" :class="{active:activeType === index}">{{item.name}}</li>
        </ul>
    </div>
    //右侧菜单列表
    <div class="divMenu">
        <div class="divItem" v-for="(item,index) in dishList" :key="index" @click="dishDetails(item)">
            <el-image :src="imgPathConvert(item.image)" >
                <div slot="error" class="image-slot">
                  <img src="./images/noImg.png"/>
                </div>
            </el-image>
            <div class="divName">{{item.name}}</div>
            <div class="divDesc">{{item.description}}</div>
            <div class="divDesc">{{'月销' + (item.saleNum ? item.saleNum : 0)  }}</div>
            <div class="divBottom"><span>￥</span><span>{{item.price/100}}</span></div>
            <div class="divNum">
              <div class="divSubtract" v-if="item.number > 0">
                <img src="./images/subtract.png" @click.prevent.stop="subtractCart(item)"/>
              </div>
              <div class="divDishNum">{{item.number}}</div>
              <div class="divTypes" v-if="item.flavors && item.flavors.length > 0 && !item.number " @click.prevent.stop="chooseFlavorClick(item)">选择规格</div>
              <div class="divAdd" v-else>
                  <img src="./images/add.png" @click.prevent.stop="addCart(item)"/>
              </div>
            </div>
        </div>
    </div>
</div>
```

点击左上角的“头像图标”可以进入“个人中心”页面。

**跳转个人中心页面实现代码如下：**

```javascript
<div class="divHead">
    <img src="./images/user.png" @click="toUserPage"/>
</div>
```



#### 3) 个人中心页面

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image048.gif" alt="descript" style="zoom:50%;" />

个人中心页面包含用户的“账号名”、“电话”和“地址”，其数据会与登陆者的数据相关联并自动初始化。点击“地址管理”条框，便能响应click事件调用toAddressPage方法跳转至address.html进行地址编辑操作。点击“退出登陆”按钮便能响应click事件调用toPageLogin方法跳转至login.html重新登录。

**个人中心页面设计代码如下：**

```javascript
<div id="user" class="app">
    <div class="divHead">
        <div class="divTitle">
            <i class="el-icon-arrow-left" @click="goBack"></i>个人中心
        </div>
        <div class="divUser">
            <img src="./../images/headPage.png"/>
            <div class="desc">
                <div class="divName">
                    {{userName}}
                    <img src="./../images/sex.png"/>
                </div>
                <div class="divPhone">{{userPhone}}</div>
            </div>
        </div>
    </div>
    <div class="divContent">
        <div class="divLinks">
            <div class="item" @click="toAddressPage">
                <img src="./../images/locations.png"/>
                <span>地址管理</span>
                <i class="el-icon-arrow-right"></i>
            </div>
            <div class="divSplit"></div>
        </div>
        <div class="quitLogin" @click="toPageLogin">
            退出登录
        </div>
    </div>
</div>
```

**个人信息获取实现代码如下：**

```java
created(){
    this.userName =sessionStorage.getItem("userName")
    this.userPhone =sessionStorage.getItem("userPhone")
    this.initData()
},
```

 

#### 4) 地址管理页面

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image052.jpg" alt="descript" style="zoom:50%;" />

每个用户可以添加若干个地址，每个地址有三种类别“家”、“学校”、“公司”可以设定，收货人的性别是“男”则会自动加上称呼“先生”，收货人的性别是“女”则会自动加上称呼“女士”，点击“圆圈”可以响应`click`事件调用`setDefaultAddress(item)`方法设定默认地址，点击右侧的“铅笔”图标可以响应`click`事件调用`toAddressEditPage(item)`方法对地址进行修改编辑，点击下方的“+添加收货地址”按钮可以跳转到`add-address.html`页面进行地址添加。

**地址页面设计代码如下：**

```javascript
<div class="divContent">
    <div class="divItem" v-for="(item,index) in addressList" :key="index" @click.capture="itemClick(item)">
        <div class="divAddress">
            <span :class="{spanCompany:item.label === '公司',spanHome:item.label === '家',spanSchool:item.label === '学校'}">{{item.label}}</span>
            {{item.detail}}
        </div>
        <div class="divUserPhone">
            <span>{{item.consignee}}</span>
            <span>{{item.sex === '0' ? '女士' : '先生'}}</span>
            <span>{{item.phone}}</span>
        </div>
        <img src="./../images/edit.png" @click.stop.prevent="toAddressEditPage(item)"/>
        <div class="divSplit"></div>
        <div class="divDefault" >
            <img src="./../images/checked_true.png" v-if="item.isDefault === 1">
            <img src="./../images/checked_false.png" @click.stop.prevent="setDefaultAddress(item)" v-else>设为默认地址
        </div>
    </div>
</div>
```



#### 5) 下单页面

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image055.jpg" alt="descript" style="zoom:50%;" />

页面上方显示的是“收获地址信息”，页面中间显示的是“订单明细”，包括“菜品名称”、“数量”、“价格”，页面下方是总金额和支付按钮。

下单页面设计代码如下：

```javascript
<div class="divAddress">
    <div @click="toAddressPage">                    
        <div class="address">{{address.detail}}</div>
        <div class="name">
            <span>{{address.consignee}}{{address.sex === '1' ? '先生':'女士'}}</span>
            <span>{{address.phone}}</span>
        </div>
        <i class="el-icon-arrow-right"></i>
    </div>
    <div class="divSplit"></div>
    <div class="divFinishTime">预计{{finishTime}}送达</div>
</div>
<div class="order">
    <div class="title">订单明细</div>
    <div class="divSplit"></div>
    <div class="itemList">
        <div class="item" v-for="(item,index) in cartData" :key="index">
            <el-image :src="imgPathConvert(item.image)">
                <div slot="error" class="image-slot">
                    <img src="./../images/noImg.png"/>
                </div>
            </el-image>
            <div class="desc">
                <div class="name">{{item.name}}</div>
                <div class="numPrice">
                    <span class="num">x{{item.number}}</span>
                    <div class="price">
                        <span class="spanMoney">￥</span>{{item.amount}}
                        </div>
                    </div>
                </div>
            </div>
    </div>
</div>
```

底部总金额与支付按钮设计代码如下：

```javascript
<div class="divCart">
    <div :class="{imgCartActive: cartData && cartData.length > 0, imgCart:!cartData || cartData.length<1}"></div>
    <div :class="{divGoodsNum:1===1, moreGoods:cartData && cartData.length > 99}" v-if="cartData && cartData.length > 0">{{ goodsNum }}</div>
    <div class="divNum">
        <span>￥</span>
        <span>{{goodsPrice}}</span>
    </div>
    <div class="divPrice"></div>
    <div :class="{btnSubmitActive: cartData && cartData.length > 0, btnSubmit:!cartData || cartData.length<1}" @click="goToPaySuccess">
        去支付        
    </div>
</div>
```



#### 6) 支付成功页面

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image059.jpg" alt="descript" style="zoom:50%;" />

支付成功之后，可以点击左上的“回退”按钮或者右上的“home”按钮，跳转到主页面，也可以点击下方的“查看订单”按钮跳转到订单页面。

**跳转页面方法设计如下：**

```javascript
methods:{
    goBack(){
        window.requestAnimationFrame(()=>{
            window.location.replace('/front/index.html')
        })   
    },
    toOrderPage(){
        window.requestAnimationFrame(()=>{
            window.location.replace('/front/page/order.html')
        })  
    },
    toMainPage(){
        window.requestAnimationFrame(()=>{
            window.location.replace('/front/index.html')
        })  
    },
```

 

## 4.2 功能模块实现

创建`entity，controller，service，mapper`，分别对应：订餐系统中实现的类、类的方法、对应类提供的服务、对应类的映射数据库表。

### 4.2.1 管理端

#### 1) 管理员登录

给`EmployeeController`类添加一个`login`方法

`@RequestBody`主要用于接收前端传递给后端的json字符串（请求体中的数据）

`HttpServletRequest request`作用：如果登录成功，将员工对应的id存到session一份，这样想获取一份登录用户的信息就可以随时获取出来。

```java
public R<Employee> login(HttpServletRequest request, @RequestBody Employee employee){
        //1.将页面提交的pw进行md5加密
        String password = employee.getPassword();
        password = DigestUtils.md5DigestAsHex(password.getBytes());

        //2.根据页面提交的用户名查询数据库
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Employee::getUsername, employee.getUsername());
        Employee emp = employeeService.getOne(queryWrapper);

        //3.没有查询到结果返回登陆失败
        if(emp == null){
            return R.error("此用户不存在");
        }

        //4.密码比对，不一致返回登陆失败
        if(!emp.getPassword().equals(password)){
            return R.error("密码错误，登陆失败");
        }

        //5.查看管理员状态，如果为已禁用，则返回员工已禁用结果
        if(emp.getStatus() == 0){
            return R.error("账号已禁用");
        }

        //6.登陆成功，将管理员id存入Session并返回登陆结果
        request.getSession().setAttribute("employee", emp.getId());
        return R.success(emp);
        }
```



#### 2) 管理员退出

员工登录成功后，页面跳转到后台系统首页面`(backend/index.html)`,此时会显示当前登录用户的姓名，如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。

在`EmployeeController`类中添加`logout`方法

```java
//7.退出登录
    @PostMapping("/logout")
    public R<String> logout(HttpServletRequest request){
        //清理Session上保存的当前管理员的ID
        request.getSession().removeAttribute("employee");
        return R.success("退出成功");
    }
```



#### 3) 员工管理

##### a.添加管理员（员工）

前端通过表单提交的方式向服务器发送请求携带参数(json格式)，请求的url为：

> `http://localhost:8014/employee`

然后后端请求的`url`在`controller`层编写代码，提交的参数中没有的属性则需要在控制器方法中进行手动的设置，然后调用`service`层，`service`层调用`dao`层来保存员工数据，最后以`json`的格式相应给客户端。

```java
//8.添加管理员
    @PostMapping
    public R<String> save(HttpServletRequest request, @RequestBody Employee employee){
        log.info("新增管理员，管理员信息：{}", employee.toString());

        //设置初始密码123456并进行MD5加密
        employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));

        //employee.setCreateTime(LocalDateTime.now());
        //employee.setUpdateTime(LocalDateTime.now());
        //获得当前登陆用户的ID
        //Long empId = (Long)request.getSession().getAttribute("employee");
        //employee.setCreateUser(empId);
        //employee.setUpdateUser(empId);

        employeeService.save(employee);
        return R.success("新增管理员成功！");
    }
```

由于在数据库中的`username`字段设置了`unique`，所以当前端的表单中出现了同一个个`username`时，后端由于`dao`层出现`sql`异常无法添加，所以我们应该设置一个全局异常处理器来处理出现的异常情况响应给浏览器。

```java
 //进行异常处理
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandler(SQLIntegrityConstraintViolationException ex){
        log.error(ex.getMessage());

        if(ex.getMessage().contains("Duplicate entry")){
            String[] split =  ex.getMessage().split(" ");
            String msg = split[2] + "已存在";
            return R.error(msg);
        }

        return R.error("未知错误");
    }
```

目前存在的管理员为admin

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image068.jpg)

点击添加员工并填入信息

​            <img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image070.jpg" alt="descript" style="zoom:50%;" />

添加成功

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image072.jpg)

##### b.员工信息分页查询

登录到员工管理页面后，我们需要将数据库中的员工信息进行分页查询到前端进行展示，这里我们使用了mybatisplus提供的分页插件：

```java
//配置MybatisPlus分页插件
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
```

前端请求路径为：

> `http: //localhost : 8080/ employee/ page ?page=1&pageSize=10`

然后根据前端需要的请求路径和参数来编写我们的`controller`方法来处理请求：

```java
 //9.管理员信息分页查询
    @GetMapping("/page")
    public R<Page> page(int page, int pageSize, String name){
        log.info("page = {}, pageSize = {}, name = {}", page, pageSize, name);

        //构造分页构造器
        Page pageInfo = new Page(page, pageSize);

        //构造条件构造器
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper();

        //添加过滤条件
        queryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name);

        //添加排序条件
        queryWrapper.orderByDesc(Employee::getUpdateTime);

        //执行查询
        employeeService.page(pageInfo, queryWrapper);

        return R.success(pageInfo);
    }
```



##### c.修改员工帐号状态及信息功能

编辑功能就是修改员工的基本信息，当我们点击时会出现会出现员工的原来的基本信息，将员工的基本信息回显到表单中，也就是前端通过一个**get**请求去通过请求参数id来调用service层进而调用dao层获取员工的基本信息，最后再进行修改。

```java
//10.根据ID修改管理员信息
    @PutMapping
    public R<String> update(HttpServletRequest request, @RequestBody Employee employee){
        log.info(employee.());

        long id = Thread.currentThread().getId();
        log.info("线程ID为：{}", id);

        //Long empId = (Long)request.getSession().getAttribute("employee");
        //employee.setUpdateTime(LocalDateTime.now());
        //employee.setUpdateUser(empId);
        employeeService.updateById(employee);

        return R.success("管理员信息修改成功!");
    }
```

> 后端`@RequestBody`注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即`:@RequestBody`后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性。

当我们修改完后点击'保存'按钮时，会出现更新失败的情况。

**原因：**通过id修改员工的信息，而前端请求接收到的id是js处理过后的，与后端java中的在数据库保存的id是有精度损失的情况，所以我们无法通过比较前后端的Long型id来进行修改员工信息，即无法处理此次请求。(由上图可知响应给浏览器的id非String类型)

```java
//11.根据id查询管理员信息
    @GetMapping("/{id}")
    public R<Employee> getById(@PathVariable Long id){
        Employee employee = employeeService.getById(id);
        if(employee != null){
            return R.success(employee);
        }
        return R.error("没有查询到对应管理员信息");
    }
```

所以解决的办法就是在服务端给页面响应json数据时进行处理，将long型数据统一转换为String字符串。

**解决方法：**

1.   提供对象转换器JacksonObjectMapper,基于jackson进行java对象到json的转换

2.   在webMvcConfig配置类中扩展Spring MVC的消息转换器，在此消息转换器中使用对象转换器JacksonObjectMapper进行java对象到json数据的转换

```java
/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
//扩展mvc框架的消息转换器
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters){
        //创建消息转换器对象
        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
        //设置对象转换器，底层使用jackson将java对象转成json
        messageConverter.setObjectMapper(new JacksonObjectMapper());
        //将上面的消息转换器对象追加到mvc框架的转换器容器
        converters.add(0, messageConverter);
    }
```

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image077.jpg)

##### d.公共字段填充

由于在每个类中都存在`createTime，updateTime`等每个表(类)都有的字段，但这些字段都是需要在插入表中为非null，这就需要我们在每个保存数据的方法中都需要手动set值进行插入，`mybatisplus`就为我们提供了一种为所有表中存在的公共字段进行填充。

**步骤：**

在需要填充的属性中加上`@TableField`，其中里面的属性fill对应的值对应三个值，`FieldFill.INSERT`(插入时填充该字段)，`Fill.UPDATE`(更新时填充该字段)，`FieldFill.INSERT_UPDATE`(插入或者更新时填充该字段)。创建一个类去实现`MetaObjectHandler`接口，并且重写`insertFill`和`updateFill`两个方法

```java
public class MyMetaObjectHandler implements MetaObjectHandler {
    //插入自动填充
    @Override
    public void insertFill(MetaObject metaObject) {
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("createUser", BaseContext.getCurrentId());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }
    //更新自动填充
    @Override
    public void updateFill(MetaObject metaObject) {
        long id = Thread.currentThread().getId();
        log.info("线程ID为：{}", id);

        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }
}
```



#### 4) 分类管理

##### a.删除菜品分类

删除菜品分类，由于`dish`表和`setmeal`表中有菜品分类的字段(`category-id)`，所以我们在删除该菜品分类信息时需要去判断该菜品分类是否关联了某个菜品或者某个套餐，如果关联了则抛出异常，并向前端展示；如果没有关联则直接删除即可。

在`CategoryService`业务层进行创建一个`remove`方法(实现删除菜品分类信息功能)，然后让`CategoryServiceImpl`去实现该业务逻辑。

```java
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {

    @Autowired
    private DishService dishService;
    @Autowired
    private SetMealService setMealService;

    //根据id删除分类，删除之前进行判断
    @Override
    public void remove(Long id) {
        LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>();
        //添加查询条件，根据分类id进行查询
        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);
        int count1 = dishService.count(dishLambdaQueryWrapper);

        //查询当前分类是否关联菜品，如果关联，抛出异常
        if(count1 > 0){
            throw new CustomException("当前分类有菜品，不能删除!");
        }
        LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
        //添加查询条件，根据分类id进行查询
        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId, id);
        int count2 = setMealService.count(setmealLambdaQueryWrapper);

        //查询当前分类是否关联套餐，如果关联，抛出异常
        if(count2 > 0){
            throw new CustomException("当前分类有套餐 ，不能删除!");
        }
        //正常删除
        super.removeById(id);
    }
}
```



##### b.自定义业务异常类

```java
//自定义业务异常
public class CustomException extends RuntimeException{
    public CustomException(String message){
        super(message);
    }
}
 	@ExceptionHandler(CustomException.class)
    public R<String> exceptionHandler(CustomException ex){
        return R.error(ex.getMessage());
    }
```



#### 5) 菜品管理

##### a.新增菜品

1. **菜品分类下拉框功能**

​                 <img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image081.jpg" alt="descript" style="zoom:50%;" />

 在`CategoryController`层去实现该请求：

```java
//根据条件查询分类数据
    @GetMapping("/list")
    public R<List<Category>> list(Category category){
        LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(category.getType() != null, Category::getType, category.getType());
        queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);
        List<Category> list = categoryService.list(queryWrapper);
        return R.success(list);
    }
```

2. **文件上传与下载**

页面发送请求进行图片的上传，请求服务端将图片保存到服务器。专门创建一个控制层来处理文件的上传和下载的请求处理。

```java
//文件上传下载
@RestController
@RequestMapping("/common")
public class CommonController {

    @Value("${takeaway.path}")
    private String basePath;

    //文件上传
    @PostMapping("/upload")
    public R<String> upload(MultipartFile file){
        //file是一个临时文件，需要转存到指定位置，否则本次请求完成之后临时文件会删除

        //原始文件名
        String originalFilename = file.getOriginalFilename();
        String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));

        //使用UUID重新生成文件名
        String fileName = UUID.randomUUID().toString() + suffix;

        //创建目录对象
        File dir = new File(basePath);
        if(!dir.exists()){
            dir.mkdirs();
        }

        try {
            file.transferTo(new File(basePath + fileName));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return R.success(fileName);
    }

    //文件下载
    @GetMapping("/download")
    public void download(String name, HttpServletResponse response){
            //输入流，读取文件内容
        try {
            FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));

            //输出流，通过输出流将文件写回浏览器
            ServletOutputStream outputStream = response.getOutputStream();

            response.setContentType("image/jpeg");

            int len = 0;
            byte[] bytes = new byte[1024];
            while((len = fileInputStream.read(bytes)) != -1){
                outputStream.write(bytes, 0,len);
                outputStream.flush();
            }
            outputStream.close();
            fileInputStream.close();

        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

3. **将新增菜品保存到数据库**

将数据填入表单后进行提交到后端请求保存到数据库中，但是表单提交的信息不仅只有`cateory`一张表的信息，还有`dish_flavor`表的信息，所以我们无法通过简单的一个实体类去保存数据。所以**需要导入一个DishDto，用于封装页面提交的数据**。

> `DTO`,全称为`Data Transfer Object`,即数据传输对象，一般用于展示层与服务层之间的数据传输。

然后在`dishService`业务层创建一个方法处理保存菜品同时保存对应的口味数据到数据库，然后`dishServiceImpl`去实现该业务逻辑。

```java
@Transactional
    public void saveWithFlavor(DishDto dishDto) {
        //保存菜品基本信息到dish
        this.save(dishDto);
        Long dishId = dishDto.getId(); //菜品id

        List<DishFlavor> flavors = dishDto.getFlavors(); //菜品口味
        flavors = flavors.stream().map((item)->{
            item.setDishId(dishId);
            return item;
        }).collect(Collectors.toList());

        //保存菜品口味到dish_flavor
        dishFlavorService.saveBatch(flavors);
    }
```

在此方法上我们开始事务`@Transactional`并且在主程序中开启事务管理`@EnableTransactionManagement`：

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image083.jpg)

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image085.jpg" alt="descript" style="zoom: 80%;" />

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image087.jpg" alt="descript" style="zoom:80%;" />

##### b.菜品信息的分页查询

分页查询将菜品信息展示:难点在于分页查询不仅需要将属于菜品的字段进行展示,并且还需要展示该菜品的菜品分类的名(属于另一张表的字段),这时候dish就无法满足,就需要一个dto来满足响应的内容。

```java
@GetMapping("/page")
    public R<Page> page(int page, int pageSize, String name){
        //构造分页构造器
        Page<Dish> pageInfo = new Page<>(page, pageSize);
        Page<DishDto> dishDtoPage = new Page<>();

        //构造条件构造器
        LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();

        //添加过滤条件
        queryWrapper.like(name != null, Dish::getName, name);

        //添加排序条件
        queryWrapper.orderByDesc(Dish::getUpdateTime);

        //执行查询
        dishService.page(pageInfo, queryWrapper);

        //对象拷贝
        BeanUtils.copyProperties(pageInfo, dishDtoPage, "records");

        List<Dish> records = pageInfo.getRecords();
        List<DishDto> list = records.stream().map((item)->{
            DishDto dishDto = new DishDto();

            BeanUtils.copyProperties(item, dishDto);

            Long categoryId = item.getCategoryId();
            Category category = categoryService.getById(categoryId);
            if(category != null){
                String categoryName = category.getName();
                dishDto.setCategoryName(categoryName);
            }
            return dishDto;
        }).collect(Collectors.toList());

        dishDtoPage.setRecords(list);

        return R.success(dishDtoPage);
    }
```



##### c.修改菜品信息

1. **菜品分类下拉框中数据展示并回显原菜品分类**

​                      <img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image089.jpg" alt="descript" style="zoom:67%;" />

将复用新增菜品时同一个请求路径`@GetMapping("/list")`所映射的控制器方法`R<List<Category>> list(Category category)`来达到菜品分类下拉框中数据展示，并且回显原菜品分类，要结合第2点一起才能实现。

2. **将dish基本信息和dishFlavor回显到修改页面**

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image091.jpg)

这里的逻辑其实和前面的分页查询菜品差不多，都是基本的实体类`dish`和`dish_flavor`都无法满足响应给浏览器页面进行展示，所以才需要一个类既有dish的基本信息，又有每个`dish`对应的`dish_flavor`，所以会创建一个`DishDto`类封装并且响应给页面，也是因为后端数据库设计时一(`dish`)对多(`dish_flavor`)实体表的对应关系，基本业务逻辑如下：

```java
//根据id查询菜品信息和对应口味信息
    public DishDto getByIdWithFlavor(Long id) {
        //查询菜品基本信息
        Dish dish = this.getById(id);


        DishDto dishDto = new DishDto();
        BeanUtils.copyProperties(dish, dishDto);

        //查询当前菜品对应口味
        LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(DishFlavor::getDishId, dish.getId());
        List<DishFlavor> flavors = dishFlavorService.list(queryWrapper);
        dishDto.setFlavors(flavors);

        return dishDto;
    }
```

3. **图片的回显到修改页面**

 复用已经写好的`commonController`类中的`download`控制器方法即可。

4. **将修改的信息更新到数据库**

更新操作与新增菜品操作的业务逻辑有点不同，更新数据的请求是put请求，而插入数据的请求是post请求，并且如果把新增菜品的功能的业务逻辑复用到更新菜品的功能会出现异常，由于主键唯一无法进行插入数据，并且更新操作是根据唯一id进行更新，所以更新数据操作的业务逻辑的代码如下：(写在dish的业务层)

```java
@Override
    public void updateWithFlavor(DishDto dishDto) {
        //更新dish表
        this.updateById(dishDto);
        //更新dish_flavor
        LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(DishFlavor::getDishId, dishDto.getId());

        dishFlavorService.remove(queryWrapper);

        List<DishFlavor> flavors = dishDto.getFlavors();

        flavors = flavors.stream().map((item)->{
            item.setDishId(dishDto.getId());
            return item;
        }).collect(Collectors.toList());

        dishFlavorService.saveBatch(flavors);
    }
```



##### d.批量管理菜品操作

单独停售和删除的操作：

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image094.gif)

批量停售和删除的操作：

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image096.gif)

并且对正在用户端售卖的菜品无法进行批量删除操作。

将批量删除和修改售卖状态的业务逻辑代码写到`DishController`层，将菜品与正在售卖的套餐进行关联而无法删除的逻辑写在`DishServer`层。

```java
//对菜品批量或者是单个进行停售或者是起售
    @PostMapping("/status/{status}")
    public R<String> status(@PathVariable("status") Integer status,@RequestParam List<Long> ids){
        LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper();
        queryWrapper.in(ids !=null,Dish::getId,ids);
        //根据数据进行批量查询
        List<Dish> list = dishService.list(queryWrapper);
        for (Dish dish : list) {
            if (dish != null){
                dish.setStatus(status);
                dishService.updateById(dish);
            }
        }
        return R.success("售卖状态修改成功");
    }

    //
    @DeleteMapping
    public R<String> delete(@RequestParam("ids") List<Long> ids){
        //根据菜品id在stemeal_dish表中查出哪些套餐包含该菜品
        LambdaQueryWrapper<SetmealDish> setmealDishLambdaQueryWrapper = new LambdaQueryWrapper<>();
        setmealDishLambdaQueryWrapper.in(SetmealDish::getDishId,ids);
        List<SetmealDish> SetmealDishList = setMealDishService.list(setmealDishLambdaQueryWrapper);
        //如果菜品没有关联套餐，直接删除就行  其实下面这个逻辑可以抽离出来，这里我就不抽离了
        if (SetmealDishList.size() == 0){
            //这个deleteByIds中已经做了菜品起售不能删除的判断力
            dishService.deleteByIds(ids);
            LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
            queryWrapper.in(DishFlavor::getDishId,ids);
            dishFlavorService.remove(queryWrapper);
            return R.success("菜品删除成功");
        }

        //如果菜品有关联套餐，并且该套餐正在售卖，那么不能删除
        //得到与删除菜品关联的套餐id
        ArrayList<Long> Setmeal_idList = new ArrayList<>();
        for (SetmealDish setmealDish : SetmealDishList) {
            Long setmealId = setmealDish.getSetmealId();
            Setmeal_idList.add(setmealId);
        }
        //查询出与删除菜品相关联的套餐
        LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
        setmealLambdaQueryWrapper.in(Setmeal::getId,Setmeal_idList);
        List<Setmeal> setmealList = setMealService.list(setmealLambdaQueryWrapper);
        //对拿到的所有套餐进行遍历，然后拿到套餐的售卖状态，如果有套餐正在售卖那么删除失败
        for (Setmeal setmeal : setmealList) {
            Integer status = setmeal.getStatus();
            if (status == 1){
                return R.error("删除的菜品中有关联在售套餐,删除失败！");
            }
        }

        //要删除的菜品关联的套餐没有在售，可以删除
        //这下面的代码并不一定会执行,因为如果前面的for循环中出现status == 1,那么下面的代码就不会再执行
        dishService.deleteByIds(ids);
        LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.in(DishFlavor::getDishId,ids);
        dishFlavorService.remove(queryWrapper);
        return R.success("菜品删除成功");
    }

@Override
    @Transactional
    public void deleteByIds(List<Long> ids) {
        //构造条件查询器
        LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
        //先查询该菜品是否在售卖，如果是则抛出业务异常
        queryWrapper.in(ids!=null,Dish::getId,ids);
        List<Dish> list = this.list(queryWrapper);
        for (Dish dish : list) {
            Integer status = dish.getStatus();
            //如果不是在售卖,则可以删除
            if (status == 0){
                this.removeById(dish.getId());
            }else {
                //此时应该回滚,因为可能前面的删除了，但是后面的是正在售卖
                throw new CustomException("删除菜品中有正在售卖菜品,无法全部删除");
            }
        }
    }

```



#### 6) 套餐管理

新增套餐，分页查询，修改套餐和批量管理套餐的实现套路和逻辑基本和菜品管理模块相同，不再赘述。

#### 7) 订单明细

##### a.订单明细的分页查询

用户在用户端进行外卖下单后，可以从订单明细模块中分页实时显示所有用户们的订单信息，并且可以通过订单号，订单下单的开始时间和结束时间两种查询条件进行分页查询。

```java
@GetMapping("/page")
    public R<Page> page(int page, int pageSize, String number, String beginTime, String endTime){
        //分页构造器对象
        Page<Orders> pageInfo = new Page<>(page,pageSize);
        //构造条件查询对象
        LambdaQueryWrapper<Orders> queryWrapper = new LambdaQueryWrapper<>();

        //添加查询条件  动态sql  字符串使用StringUtils.isNotEmpty这个方法来判断
        //这里使用了范围查询的动态SQL，这里是重点！！！
        queryWrapper.like(number!=null,Orders::getNumber,number)
                .gt(StringUtils.isNotEmpty(beginTime),Orders::getOrderTime,beginTime)
                .lt(StringUtils.isNotEmpty(endTime),Orders::getOrderTime,endTime);

        orderService.page(pageInfo,queryWrapper);
        return R.success(pageInfo);
    }
```

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image099.jpg)

##### b.查看订单明细和修改订单状态

​           <img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image101.jpg" alt="descript" style="zoom: 50%;" />

将已经完成派送的订单修改状态为订单已完成，代码实现在`DishController`层：

```java
@PutMapping
    public R<String> orderStatusChange(@RequestBody Map<String,String> map){

        String id = map.get("id");
        Long orderId = Long.parseLong(id);
        Integer status = Integer.parseInt(map.get("status"));

        if(orderId == null || status==null){
            return R.error("传入信息不合法");
        }
        Orders orders = orderService.getById(orderId);
        orders.setStatus(status);
        orderService.updateById(orders);

        return R.success("订单状态修改成功");
    }
```

可见订单状态变为已完成。

![descript](file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image103.jpg)

### 4.2.2 移动端

#### 1) 用户登录

实现方法和`Employee`一样，给`UserController`类添加一个`login`方法。

```java
/**
     * 移动端用户登录
     */
    @PostMapping("/login")
    public R<User> login(HttpServletRequest request, @RequestBody User user){
        //1.将页面提交的pw进行md5加密
        String password = user.getPassword();
        password = DigestUtils.md5DigestAsHex(password.getBytes());

        //2.根据页面提交的用户名查询数据库
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(User::getUsername, user.getUsername());
        User use = userService.getOne(queryWrapper);

        //3.没有查询到结果返回登陆失败
        if(use == null){
            return R.error("此用户不存在");
        }

        //4.密码比对，不一致返回登陆失败
        if(!use.getPassword().equals(password)){
            return R.error("密码错误，登陆失败");
        }

        //5.查看管理员状态，如果为已禁用，则返回员工已禁用结果
        if(use.getStatus() == 0){
            return R.error("账号已禁用");
        }

        //6.登陆成功，将管理员id存入Session并返回登陆结果
        request.getSession().setAttribute("user", use.getId());
        return R.success(use);
    }
```



#### 2) 导入用户地址簿

地址簿指的是移动端消费者用户的地址信息，用户登录成功后可以维护自己的地址信息。同一个用户可以有多个地址信息，但是只能有一个默认地址。

<img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image105.jpg" alt="descript" style="zoom:65%;" /><img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image107.jpg" alt="descript" style="zoom:65%;" /><img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image109.jpg" alt="descript" style="zoom:65%;" />

地址簿表：

​        <img src="file:///C:/Use，rs/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image111.jpg" alt="descript" style="zoom: 60%;" /> 

对应`Controller`层实现的逻辑：

```java
 //查询指定用户的全部地址
    @GetMapping("/list")
    public R<List<AddressBook>> list(AddressBook addressBook) {
        addressBook.setUserId(BaseContext.getCurrentId());
        log.info("addressBook:{}", addressBook);

        //条件构造器
        LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(null != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());
        queryWrapper.orderByDesc(AddressBook::getUpdateTime);

        //SQL:select * from address_book where user_id = ? order by update_time desc
        return R.success(addressBookService.list(queryWrapper));
    }
```



#### 3) 菜品展示

- 页面`(front/index.html)`发送`ajax`请求, 获取分类数据( 菜品分类和套餐分类)
- 页面发送ajax请求，获取第一个分类下的菜品或者套餐

开发菜品展示功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。首页加载完成后，还发送了一次ajax请求用于加载购物车数据，从静态json文件获取数据。

```java
//根据条件查询对应菜品数据
    @GetMapping("/list")
    public R<List<Dish>> list(Dish dish){
        LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());
        queryWrapper.eq(Dish::getStatus, 1);
        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);
        List<Dish> list = dishService.list(queryWrapper);
        return R.success(list);
    }
```

移动端用户可以将菜品或者套餐添加到购物车。对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车；对于套餐来说，可以直接点击加号将当前套餐加入购物车。在购物车中可以修改菜品和套餐的数量，也可以清空购物车。

​    <img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image114.jpg" alt="descript" style="zoom:70%;" /><img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image116.jpg" alt="descript" style="zoom:70%;" />

对应逻辑实现在`ShoppingCartController`层：

```java
/**
     * 添加购物车
     * @param shoppingCart
     * @return
     */
    @PostMapping("/add")
    public R<ShoppingCart> add(@RequestBody ShoppingCart shoppingCart){
        log.info("购物车数据:{}",shoppingCart);

        //设置用户id，指定当前是哪个用户的购物车数据
        Long currentId = BaseContext.getCurrentId();
        shoppingCart.setUserId(currentId);

        Long dishId = shoppingCart.getDishId();

        LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,currentId);

        if(dishId != null){
            //添加到购物车的是菜品
            queryWrapper.eq(ShoppingCart::getDishId,dishId);

        }else{
            //添加到购物车的是套餐
            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
        }

        //查询当前菜品或者套餐是否在购物车中
        //SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?
        ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);

        if(cartServiceOne != null){
            //如果已经存在，就在原来数量基础上加一
            Integer number = cartServiceOne.getNumber();
            cartServiceOne.setNumber(number + 1);
            shoppingCartService.updateById(cartServiceOne);
        }else{
            //如果不存在，则添加到购物车，数量默认就是一
            shoppingCart.setNumber(1);
            shoppingCart.setCreateTime(LocalDateTime.now());
            shoppingCartService.save(shoppingCart);
            cartServiceOne = shoppingCart;
        }

        return R.success(cartServiceOne);
    }

    /**
     * 查看购物车
     * @return
     */
    @GetMapping("/list")
    public R<List<ShoppingCart>> list(){
        log.info("查看购物车...");

        LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());
        queryWrapper.orderByAsc(ShoppingCart::getCreateTime);

        List<ShoppingCart> list = shoppingCartService.list(queryWrapper);

        return R.success(list);
    }

    /**
     * 清空购物车
     * @return
     */
    @DeleteMapping("/clean")
    public R<String> clean(){
        //SQL:delete from shopping_cart where user_id = ?

        LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());

        shoppingCartService.remove(queryWrapper);

        return R.success("清空购物车成功");
    }
```



#### 5) 下单

- 在购物车中点击去结算按钮，页面跳转到订单确认页面
- 在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的默认地址
- 在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的购物车数据
- 在订单确认页面点击去支付按钮, 发送ajax请求， 请求服务端完成下单操作

开发用户下单功能，其实就是在服务端编写代码去处理前端页面发送的请求即可。

业务实现复杂，逻辑在`OrderServiceImpl`，在`Controller`层调用：

```java
@Transactional
    public void submit(Orders orders) {
        //获得当前用户id
        Long userId = BaseContext.getCurrentId();

        //查询当前用户的购物车数据
        LambdaQueryWrapper<ShoppingCart> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(ShoppingCart::getUserId,userId);
        List<ShoppingCart> shoppingCarts = shoppingCartService.list(wrapper);

        if(shoppingCarts == null || shoppingCarts.size() == 0){
            throw new CustomException("购物车为空，不能下单");
        }

        //查询用户数据
        User user = userService.getById(userId);

        //查询地址数据
        Long addressBookId = orders.getAddressBookId();
        AddressBook addressBook = addressBookService.getById(addressBookId);
        if(addressBook == null){
            throw new CustomException("用户地址信息有误，不能下单");
        }

        long orderId = IdWorker.getId();//订单号

        AtomicInteger amount = new AtomicInteger(0);

        List<OrderDetail> orderDetails = shoppingCarts.stream().map((item) -> {
            OrderDetail orderDetail = new OrderDetail();
            orderDetail.setOrderId(orderId);
            orderDetail.setNumber(item.getNumber());
            orderDetail.setDishFlavor(item.getDishFlavor());
            orderDetail.setDishId(item.getDishId());
            orderDetail.setSetmealId(item.getSetmealId());
            orderDetail.setName(item.getName());
            orderDetail.setImage(item.getImage());
            orderDetail.setAmount(item.getAmount());
            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());
            return orderDetail;
        }).collect(Collectors.toList());


        orders.setId(orderId);
        orders.setOrderTime(LocalDateTime.now());
        orders.setCheckoutTime(LocalDateTime.now());
        orders.setStatus(2);
        orders.setAmount(new BigDecimal(amount.get()));//总金额
        orders.setUserId(userId);
        orders.setNumber(String.valueOf(orderId));
        orders.setUserName(user.getName());
        orders.setConsignee(addressBook.getConsignee());
        orders.setPhone(addressBook.getPhone());
        orders.setAddress((addressBook.getProvinceName() == null ? "" : addressBook.getProvinceName())
                + (addressBook.getCityName() == null ? "" : addressBook.getCityName())
                + (addressBook.getDistrictName() == null ? "" : addressBook.getDistrictName())
                + (addressBook.getDetail() == null ? "" : addressBook.getDetail()));
        //向订单表插入数据，一条数据
        this.save(orders);

        //向订单明细表插入数据，多条数据
        orderDetailService.saveBatch(orderDetails);

        //清空购物车数据
        shoppingCartService.remove(wrapper);
    }
```

​     <img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image119.jpg" alt="descript" style="zoom:70%;" /><img src="file:///C:/Users/林颐/AppData/Local/Temp/msohtmlclip1/01/clip_image121.jpg" alt="descript" style="zoom:70%;" />

 

# 五、   总结与思考

由于实训的时间有限，因此我们只能在较短的时间内完成最主要的功能。关于系统测试的部分主要见讲解视频，同时在完成每一项功能之后，都会对其进行测试。但是我们一致认为我们还有许多值得改进的地方，列出如下：

1. 此次实现的是web页面的形式来展现相应的功能，但是实际上大家点外卖大多是在微信小程序或是相应的APP上进行实现。在较短的时间内掌握微信小程序的开发、Android开发或是IOS开发，对于我们目前的水平与精力来说着实有限，因此我们可以在课余时间内学习这方面的有关知识对齐进行完善。
2. 同时，老师利用两节课的时间为我们介绍了低代码技术。利用低代码平台，我们可以很快的对页面以及相应的功能进行开发；而不是利用java对前后端的一个按钮的点击以及数据的传送都要调试半天。在低代码平台下，利用鼠标的点击以及设置相应的命令，可以屏蔽掉相应的前后端交互的大量代码，从而可以快速构建出一个系统，并将其部署到服务器上进行产品的多次迭代。
3. 对于送餐员的数据表schema的构建以及相应功能的实现：送餐员可以查看没有配送的订单，并选择合适的订单进行接单。对于已经有配送员接单的订单，将不会在接单页面进行显示。并且把订单的状态实时更新到顾客端。

 

 